import type { NextPage } from 'next'
import Head from 'next/head'
import Image from 'next/image'
import styles from '../styles/Home.module.css'
import Slider from 'rc-slider'
import 'rc-slider/assets/index.css'
import { useEffect, useState } from 'react'
import { UIEvent } from 'react'

const Home: NextPage = () => {
  const [firstScroll, setFirstScroll] = useState(0)
  const [secondScroll, setSecondScroll] = useState(0)

  const onscroll: EventListener = (e) => {
    setFirstScroll(400 - window.scrollY * 2.5)
    setSecondScroll(200 - window.scrollY * 1.25)
  }

  useEffect(() => {
    window.addEventListener('scroll', onscroll)
  }, [])

  const maxBlurVal = 24
  const [firstBlur, setFirstBlur] = useState(maxBlurVal)
  const [secondBlur, setSecondBlur] = useState(maxBlurVal / 2)
  const [thirdBlur, setThirdBlur] = useState(0)
  const onDragged = (val: number | number[]) => {
    const value = val as number
    // max blur: 16px
    setFirstBlur(maxBlurVal - (value * maxBlurVal))
    setSecondBlur(Math.abs(maxBlurVal * value - maxBlurVal / 2))
    setThirdBlur(value * maxBlurVal)
  }

  return (
    <div className={styles.container}>
      <Head>
        <title>Focus</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <div className={styles.sliderwrap}>
          <div className={styles.slider}>
            <Slider
              onChange={onDragged}
              min={0}
              max={1}
              defaultValue={0}
              step={0.01}
              vertical
              />
          </div>
        </div>
        <div className={styles.first} style={{
          top: firstScroll.toString() + 'px',
          textShadow: '0 0 ' + firstBlur.toString() + 'px rgba(0, 0, 0, 0.8)'
        }}>
          幾何光学における焦点（しょうてん、Focus、Focal point）は、光軸に平行な光線が光学系に入射したとき、通過後の光線を延長した直線が光軸と交わる点である。レンズなどの光が両側から入射できる光学系については、焦点は2つ存在する。光学系の主点から焦点までの空気中での距離を焦点距離と呼ぶ。
          像点（ぞうてん、英: image point）は、物上の一点から出た複数本の光線が再び収束する点である。すなわち物の位置に応じて像点は複数存在する（主点・物点・像点の位置関係はレンズの公式によって表される）。 焦点は、物が無限遠にある場合の像点である。誤解を招く恐れのない場合には像点を焦点と呼ぶこともある。
          像点は概念的には点であるとされるものの、物理的には「錯乱円」と呼ばれる空間的広がりを有する。このように理想的でなくなる原因としては光学系の収差が挙げられる。収差が無視できる場合に実現できる最小の錯乱円は、光学系の開口での回折によって生じるエアリーディスクである。開口径が大きくなるほど収差は酷くなる傾向がある一方、エアリーディスク径は小さくなる。
        </div>
        <div className={styles.second} style={{
          top: secondScroll.toString() + 'px',
          textShadow: '0 0 ' + secondBlur.toString() + 'px rgba(0, 0, 0, 0.8)'
        }}>
          言語学における焦点（しょうてん）またはフォーカス (focus)とは、節の要素のうち、聞き手が前提としていない、新しい情報を伝える部分のこと。特に、そのような新情報のうち、聞き手の前提を覆そうとして伝えられる部分のこと（対比的焦点、contrastive focus）。
          話題はすべての文にあるわけではないが、焦点はすべての文にあるとされる。焦点は書き言葉では明確に標識されないことが多いが、発話では強勢・イントネーションなどにより強調されることもある。疑問詞を含む疑問文では疑問詞が焦点であり、それに対する応答の文では疑問詞に対する答が焦点である。
          文の話題が明示されている場合、焦点は文のその他の部分に含まれる。例えば日本語では、主題を示す「は」を含む文では、これによってその他の部分（普通は「は」の直後）に焦点があることが示される。
        </div>
        <div className={styles.third} style={{
          textShadow: '0 0 ' + thirdBlur.toString() + 'px rgba(0, 0, 0, 0.8)'
        }}>
        フォーカス（英: focus）は、グラフィカルユーザインタフェース (GUI) で現在入力を受け付けるよう選択されているコンポーネントを示す概念である。キーボード入力またはクリップボードのペーストは、その時点でフォーカスを持っているコンポーネントに送られる。
        この概念は、テキスト環境でのカーソルに似ている。しかし、GUIでは同時にマウスカーソルも関係してくる。マウスを動かすとマウスカーソルも動くが、フォーカスは変化しない。フォーカスは通常、マウスボタンのクリックでフォーカスを付与するコンポーネントを指定することで変更する。多くのデスクトップ環境では、キーボードからもフォーカスを変更できる。一般に「タブ」キーを押す毎に順次フォーカスを付与されるコンポーネントが変わっていき、⇧ Shift+⭾ Tabで逆順に変化していく。状況によっては、矢印キーでフォーカスを動かす場合もある。</div>
        デスクトップでのフォーカスの振る舞いは、ウィンドウ管理のポリシーが支配している。マイクロソフトやAppleのGUIでは、クリックに追随してフォーカスが移動するFFC[1]である。すなわち、あるウィンドウ内でマウスをクリックすると、そのウィンドウがフォーカスを得る。その際に同時にそのウィンドウが最前面に表示される。
        UNIXの X Window System では、マウスの移動に追随してフォーカスが移動するFFM[2]というポリシーもある。すなわち、マウスカーソルの現在位置に従ってフォーカスがウィンドウからウィンドウへ移動する。このポリシーの当然の帰結として、マウスカーソルの下が背景であってどのウィンドウの上でもない場合、どのウィンドウにもフォーカスがない状態になる。そこで、マウスカーソルがどのウィンドウ上でもない場所に移動したときは、直前までフォーカスを持っていたウィンドウが引き続きフォーカスを保持するというポリシー（英: sloppy focus）もある。なお上述のとおり、マイクロソフトのGUIは通常FFCポリシー動作だが、Windows 10ではコントロールパネルでの設定によりFFMポリシーで動作させることも可能になっている。
        どのポリシーがよいかは議論の分かれるところである。FFMの場合、マウスに何かが当たるなどしてマウスカーソルが意図せずに移動したとき、知らないうちにフォーカスも移動するという状況があり、初心者が戸惑うことがある。しかし、慣れてくると便利であり、特にフォーカスを得たウィンドウを最前面にしないポリシーと組み合わせると、様々な制御が可能になる。例えば、大きなウィンドウが背面にあって小さなウィンドウが前面にあり、これらウィンドウ間のコピー・アンド・ペーストをするときに、ウィンドウ配置（前後関係）を全く変えることなく実行できる（⎇ Alt+⭾ Tab でアクティブウィンドウを切り替える必要がない）。
        FFMは、メニューバーが個々のウィンドウ内に組み込まれているようなインタフェースでのみ実施可能である。macOS のように単一のグローバルなメニューバーが画面上端にある場合、画面下部にある小さいウィンドウのメニューを使おうとすると、まずそのウィンドウにマウスカーソルを移動させてフォーカスを与え、続いて画面上端まで他のウィンドウを横切ることなくマウスカーソルを移動させなければならない。したがって、非常に使いにくくなる。
        テキストの入力や編集ができるコンポーネントには、それぞれにカーソルが存在する。そして、そのカーソル位置でテキスト編集をするには、そのコンポーネントにフォーカスが無ければならない。
        ウィンドウ内でどのコンポーネントがデフォルトでフォーカスを得るか、コンポーネント間でどのようにフォーカスを移動するのか、はインタフェース設計の重要だが難しい問題である。間違ったところにフォーカスがあると、ユーザーはフォーカスの移動に時間を浪費することになる。逆に適切なところにフォーカスがあれば、ユーザーエクスペリエンスの向上につながる。
      </main>
    </div>
  )
}

export default Home
